## 2023HW Mobile Arsenal Tools Tips Sharing

(PS: Articles with expensive links, tools, and merchandise to read)

### Intro

HW has been around for some years, and HW 2023 is in full swing. What everyone feels at HW this year will no longer need to discuss. Combining my own expertise with real-world tasks, I'll share some of HW's mobile-side insights with common tools (AKA weapons) and their applications.

Many large-scale enterprise group OA systems provide mobile terminal login and use, these systems due to relatively closed, use groups fixed and lack of testing there are many security issues, many (loopholes) interfaces exist only in the APP or small programs, must be through the mobile reverse engineering to find these interfaces.

The reverse of the mobile terminal does not involve the environment building, packet capture analysis and algorithm call. Here I share some of the most cutting-edge, practical and efficient tools in all directions to help you become more efficient and do more with less. All of the following tools are fully featured in the MobileCTF engagement and you are welcome to try your hand at the upgrade: https://github.com/r0ysue/MobileCTF/

### Environmental Construction of Penetration Test Weapon Depot

Converse is different from forward. Converse has no official guarantee. Everything depends on fumbling and trying. A good set of reverse environment has been half successful, sometimes also need to constantly switch environment, different environment will have different error reporting and different results.

Share my environment:

Models: Pixel 1G sailfish; Reasons for choice: Google Pro Son, swipe the official original Android 7-10, swipe the Fart8 Ultimate Shell, run the Frida12-14 version of the old code as a shuttle, Frida-based shell remover dexdump, grab tool r0capture, tracker r0tracer, stable and efficient with few bugs.

Model: OnePlus 7pro; Reason for selection: CBC mobile phone dual-card dual-standby, brush Android 10 with Kali Nethunter mobile penetration toolbox, unlock the full functionality of the kernel, built-in Wireshark network card to capture packets, from the kernel file / network / system calls for monitoring detailed article: https://mp.weixin.qq.com/s/PIiGZKW6oQnOAwlCqvcU0g.

Models: Pixel 6G; Why: Google Sons, Android 12-13, running the latest Frida16, featuring the full-featured eBPF God-sees all the App's behavior, and analyzes how to get around the root/frida counter-debugging with less effort. Stronger performance, can withstand the bulk of trace, one-button hook thousands of classes and methods, brute-force positioning packet function, parameter generation location, from the packet capture to the algorithm a dragon

Models: Cloud Phone: rock5b or orangepi; Reasons for choice: NVMe SSD hard drive, GPU acceleration, smooth and unstuck Android, guaranteed speed, 10 phones virtually out of one board without the hassle of battery-packed network jitters. Pre-installed frida/lsposed shipping, the main scene is analysis-free restore algorithm and black-box algorithm call, directly run the required signature algorithm or encryption and decryption algorithm, and can be made into a HTTP interface for team members to use

Models: iPhone X; Reasons for selection: iOS One for Low 14 and One for High 16 running Frida14 and Frida16 respectively, using checkra1n and palera1 respectively to escape, iOS's App analysis has no variety of enterprise shells and anti-debugging, much simpler and more difficult mainly on the ObjC language. Language can be mastered by learning, and business shells and anti-debugging are not human. The author is now to analyze the mobile version of iOS-based, fast, efficient

Other hardware and software are a charging version of the shell removal machine Fart12, integrated with many versions of Frida/r0cap/r0tracer, IDA/charles/jadx/jeb dynamic and static debugging environment out of the box for r0env, specific introduction and access to address here: https://github.com/r0ysue/AndroidSecurityStudy

###Catch environment: Not one less!

I can't get a bag. Reverse analysis is impossible.

Not to mention small grab, small grab, can go deep into the system floor, the kernel, God perspective grab all APP traffic packets; can also be protected from the application layer, the means is ever-changing, you grab from the kernel is not helpful, can only understand from the application layer!

Most of the applications are standard with the default HTTP/SSL protection means, that is, the client verify server certificate, only need to configure Postern/Charles VPN packet capture can be retrieved, specific can see my latest video:https://www.bilibili.com/video/BV1M8411Z7rC, support to Android 13 and KernerlSU, down to Android 7, 8 are generic. On iOS, shadowrocket + Charles, configured at https://t.zsxq.com/11lQkInqh

HTTP/SSL also has a kind of defending mode, similar to the former bank U shield, that is, the server checks the client certificate, Charles typical error report is: 400 No required SSL certificate was sent, need to use r0capture to export the client certificate from the APP, import into charles, so that the server will recognize the connection from charles, concrete method and process I have a case in MobileCTF project, from judgment to resolution and operation process. The use of this kind of protection technology has been very rare.

More is the use of the framework provided by the SSL pinning function, in the APP code on the received server certificate hash, and a specific value to be compared, if not, then disconnect, Charles typical error reporting is: Client closed the connection before a request was made. Possibly the SSL certificate was rejected. Now the need to use frida to hook framework code, null its SSL pinning logic to return through, if the framework is not confused, the author used a common scheme: https://github.com/WooyunDota/DroidSSLUnpinning, if the framework is confused with a.b.c.d, then only the r0tracer bulk hook file open function or summary function, call stack for clues, find the pinner function hook null can be bypassed, MobileCTF project also has a related case.

All the above modes of sending and receiving packets use the network communication library which is native to the system, so it can directly export the sending and receiving packet flow from the system itself, such as r0capture, eCapture can realize the SSL_write and SSL_read sending and receiving packet export of the SSL library, ignoring all the protocols, framework, certificate binding, reinforcement and other complex variables of the application layer; r0capture combined with Wireshark can have a better and intuitive display of traffic, and also provides the functions of heap backtracking, client certificate export and other functions, auxiliary positioning of sending and receiving packets and algorithm location, more powerful.

Some manufacturers with strong development ability have already been dismissive of using the system's own network library, such as browsers, small programs, games, cross-platform super applications such as Douyin, etc., generally will have their own network communication SDK, in this general case, Postern+Charles VPN packet capture can be solved, such as small programs. If you add additional protection, such as SSL pinning, you need to analyze how the communication library framework itself SSL pinning is implemented, such as Douyin communication library certificate binding implementation details analysis: https://bbs.kanxue.com/thread-277996.htm, then hook specific function to bypass, this situation is the hardest, test the comprehensive converse ability, https://t.zsxq.com/11U2cH4vi, https://t.zsxq.com/11Pfh1PyU.

Of course, some banks will use their own special financial channel, from the certificate system to the transmission system is developed independently, and standards are not the same, then all the standard HTTPS based on packet capture will fail, this is the industry's strongest protection, have to completely reverse the channel they developed from scratch. There are also applications that use special binary serialized network libraries, such as protobuf, HTTP2, such as: https://bbs.kanxue.com/thread-262207.htm, all of which have a very deep understanding of the communication library, that is to say, the need for a comprehensive reverse to understand what the packet is, and how to use it.

The key idea is to do some reverse research on how to build the APP, and then do some reverse research on how to build the APP. The more generic things that people study, the easier it is to dismantle; the more specialized systems that people study, the less hard it is to dismantle.

### Algorithm Restore and Black Box Call

Android APPs have to be shelved first, and neither can be shelved, and static analysis is impossible. IOS is crashing.

iOS is easy to smash shell, frida-ios-dump smashed, Hundred Try Bailing, and if you encounter frida anti-debugging, use CrackerXI+, most of them can succeed. There's so much to be said for Android to be unhulled, one or two or three generations of hulls, each of which is different, and all kinds of obfuscations and debugs, especially disgusting. This paper introduces some common free shells, which can be separated in seconds by fart8 Ultimate, frida-dexdump, frida_fart, and the second generation function extraction shell by youpk (now used by most enterprise shell anti), which can be charged by fart12. Three generation shell dexvmp, dex2c, these can only rely on jnitrace to analyze the Java layer logic, and then manually restore the algorithm, there is no fully automatic program.

The immediate problem after the discarding is the location of the algorithm, which package, which class method is located, which is the final encryption and decryption function in the transceiver package or the location of the signature generation. I prefer to be simple and rude, and start with the most extreme scenes, full hook. Using r0tracer can directly hook all the functions under the package, one key hook all the class methods under the package overload, output parameters, call stack and return value, output a log, in the log directly search the string of values in the package, you can locate which function generated the string of values, call stack to save the complete call logic, according to the call stack to chase off the shell out of the source code to read, determine that the confirmation parameters are generated by the calculation of conversion splicing. Of course, full-scale hook is only ideal, most cases can only be based on the keyword batch hook hundreds of thousands of methods, the machine is able to withstand. PS: The Android-compatible Java layer and the iOS ObjC layer are not available for the Android C(++) layer or the iOS C and Swift layers.

If the story ends here, then you're lucky boy, because in 2023, APPs that pay a little bit of attention to security will write the core logic, the algorithm, in C to the Native layer, so that batch hook will not be able to achieve, and they won't use standard algorithms, so it's easy to be taken offline by other language rewriting algorithms, like python/go rewriting everything and trying to write an algorithm by yourself, and if not standard then try to slightly modify the standard algorithm, like md5 changing the codetable, Symmetric encryption and decryption to change the S-box or initialization algorithm plus or minus sign, improve the difficulty of the reverse, add strong confusion such as ollvm, armvmp, the difficulty of the reverse to hell level, so that your algorithm almost can not be restored, at this time you want to call the algorithm, only to simulate the execution tools such as frida/xposed rpc, cloud phone or unidbg. Of course, in general, for the APP running efficiency and execution speed, will be a little lower confusion intensity, so that there is a chance of manual reverse restore, bear palm and fish can not have both.

If we can't get the algorithm back, we can only make black-box call. xposed/lsposed and frida are both memory injection tools, you can actively call the APP algorithm and return the results, you can also make a HTTP interface for team members to call, the difference is *posed can only work in the Java layer, frida is Java/C layer can. Cloud mobile phone is inherently suitable for active call, no screen, no battery, wired network, hardware is more stable and reliable, you can open more or even change the machine, active call exposed to the interface of real machine is not suitable. Unidbg is a simulator running on x86 hardware ARM architecture SO, it mainly provides a variety of streamlined Android library environment, including CPU, files, JNI, processes, networks, and so on, let SO mistakenly think that they are running on the Android phone, then call the algorithm in it at this time, it can only simulate the implementation of C function, and Unidbg can run on x86 server with SpringBoot for batch deployment:https://github.com/cxapython/unidbg-server, the difficulty is that the environment is laborious.

## Summary

The perpetual rivalry means that the backlash will come sooner or later, as the frida used to bulk up trace how fast and furious it was, and now the frida counter-debugging is as popular. Similarly, if you want to achieve the strongest reinforcement, it means a stronger manual coding ability, write your own unique SO dynamic load, hook framework, OLLVM pass, anti-F5 flower instructions, white-box key, encryption and decryption hash algorithm, etc., the higher the originality, the greater the difficulty of reverse analysis.

All kinds of authority and resources must be checked on the server side, the client only do the MVC model of the view side presented to the user, adhere to the client zero trust principle, deployment of equipment fingerprint and server risk control strategy, based on these principles of the APP, even if the client without any protection
